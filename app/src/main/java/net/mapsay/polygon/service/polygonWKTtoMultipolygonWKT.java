/*
package net.mapsay.polygon.service;

import org.apache.logging.log4j.core.config.ConfigurationSource;
import org.apache.logging.log4j.core.config.Configurator;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;


import java.io.IOException;
import java.util.ArrayList;
import java.util.List;

public class polygonWKTtoMultipolygonWKT {
    private static Logger logger = LoggerFactory.getLogger(polygonWKTtoMultipolygonWKT.class);
    private static int Sign(List<Double> collection,int size){
        //takes double list and determine the order by the first few elements
        // 1 = ascending, -1=descending
        for (int i=0;i<size-1;i++){
            if (collection.get(i)<collection.get(i+1)){
                return 1;
            }
            else if(collection.get(i)>collection.get(i+1)){
                return -1;
            }
        }
        assert false:"error: no ascending or descending";
        return 0;
    }
    private static  boolean NotinOrder(List<Double> collection){
        //given a list array of doubles, check if the number is in order (ascending or descending)
        int num=collection.size();
        int sign=Sign(collection,num);

        for (int i=1;i<num-1;i++){
            if (sign==1){
                if(collection.get(i)>collection.get(i+1)){
                    return true;
                }
            }
            else if(sign==-1){
                if(collection.get(i)<collection.get(i+1)){
                    return true;
                }
            }
        }
        return false;
    }

    public static double Max(Double a, Double b){
        return (a>b?a:b);
    }

    public static double Min(Double a, Double b){
        return (a<b?a:b);
    }

    private static boolean Overlap(List<Double> collection){
        //the collection consists of four doubles:start1, end1, start2, and end2.
        // check if these points have overlapping part.
        if ((collection.get(2)>Min(collection.get(0),collection.get(1)))&(collection.get(2)<Max(collection.get(0),collection.get(1)))){
            return true;
        }
        else if ((collection.get(3)>Min(collection.get(0),collection.get(1)))&(collection.get(3)<Max(collection.get(0),collection.get(1)))){
            return true;
        }
        else if ((collection.get(0)>Min(collection.get(2),collection.get(3)))&(collection.get(0)<Max(collection.get(2),collection.get(3)))){
            return true;
        }


        return false;
    }

     private static boolean RunOn(Double S1X,Double S1Y,Double E1X, Double E1Y,Double S2X,Double S2Y,Double E2X, Double E2Y){
        // S=start, E=end, 1=line1, 2=line2, X=x.coordinate Y=y.coordinate
         //it will return true or false depending on the two lines having overlapping length>0
        List<Double> collection=new ArrayList<Double>();
         if ((S1Y-E1Y)==0.0&(E1Y-S2Y)==0.0&(S2Y-E2Y)==0.0){
            collection.add(S1X);collection.add(E1X);collection.add(S2X);collection.add(E2X);
            if (Overlap(collection)){ return true;}else{return  false;}
        }else if((S1X-E1X)==0.0&(E1X-S2X)==0.0&(S2X-E2X)==0.0){
             collection.add(S1Y);collection.add(E1Y);collection.add(S2Y);collection.add(E2Y);
             if (Overlap(collection)){return true;}else{return false;}
         }
         return false;
    }
    public static String polygonToMultipolygon(String WKT) {
        // it takes the WKT of a polygon and return the WKT representing the same feature in multipolygon
        // the polygon is generated by clipping a polygon using an envelope
        //System.out.println(WKT.substring(8));
        String[] coordinates,coor ;
        Double[][] coorSet;// of the format [[x1,y1],[x2,y2],...]
        List<Double> Coordinates = new ArrayList<Double>(); // store the converted string coordinates
        List<Double> tempX = new ArrayList<Double>(); // store x coordinates, used to separate polygons
        List<Double> tempY = new ArrayList<Double>();
        List<Double> YCollection = new ArrayList<Double>(); // store Y coordinate for whose Xs are the same
        List<Double> Xcollection = new ArrayList<Double>(); // store X coordinate for whose Ys are the same
        List<Double> SubX = new  ArrayList<Double>(); // store the temporary independent polygon's x coordinates
        List<Double> SubY = new  ArrayList<Double>(); // store the temporary independent polygon's y coordinates

        int num,count,sizeX,sizeY;
        String newWKT = WKT.substring(WKT.indexOf("((")+2,WKT.length()-2);
        newWKT=newWKT.replaceAll(",","");
        coordinates=newWKT.split(" ");
        num=coordinates.length;
        coor = new String[2]; //used to store a pair of string
        coorSet = new Double[num/2][2];
        count=0;
        for (String a: coordinates){
            //the last XY coordinate is unnecessary;
            count++;
            Coordinates.add(Double.parseDouble(a));
            if (count==num){ break;}
        }

        for (int i=0;i<=num/2-1;i++){
            coorSet[i][0]=Coordinates.get(2*i);
            coorSet[i][1]=Coordinates.get(2*i+1);

        }
        for (int i=0;i<num/2;i++){
            tempX.add(coorSet[i][0]);
            tempY.add(coorSet[i][1]);
//            if (tempX.size()>=2){// this only keeps the coordinates different from its adjacent ones
//                //System.out.println("Check x : "+(tempX.get(tempX.size()-1)==tempX.get(tempX.size()-2)));
//                if ((tempX.get(tempX.size()-1)-tempX.get(tempX.size()-2))==0.0){
//                    //System.out.println("There are two coordinates with the same x");
//                    if ((tempY.get(tempY.size()-1)-tempY.get(tempY.size()-2))==0.0){
//                        tempX.remove(tempX.size()-1); tempY.remove(tempY.size()-1);
//                    }
//                }
//            }
            sizeX=tempX.size();
            sizeY=tempY.size();
            if (sizeY>2){
                // check if there are canceling lines
                for (int j=0;j<sizeY-2;j++){
                    System.out.println("the size of list is "+sizeX);
                    System.out.println(RunOn(tempX.get(j),tempY.get(j),tempX.get(j+1),tempY.get(j+1),tempX.get(sizeX-2),tempY.get(sizeY-2),tempX.get(sizeX-1),tempY.get(sizeY-1)));
                    if (RunOn(tempX.get(j),tempY.get(j),tempX.get(j+1),tempY.get(j+1),tempX.get(sizeX-2),tempY.get(sizeY-2),tempX.get(sizeX-1),tempY.get(sizeY-1))){
                        SubX=tempX.subList(j+1,sizeX-1);
                        System.out.println("size of subx is "+SubX.size());
                        SubY=tempY.subList(j+1,sizeY-1);
                        tempX=tempX.subList(0,j+1);tempX.add(coorSet[i][0]);
                        tempY=tempY.subList(0,j+1);tempY.add(coorSet[i][1]);
                        //for (Double a : SubX){System.out.println(a);}
                        break;
                    }
                }
            }

        }
        System.out.println("The size of the final polygon is "+tempY.size());


        return null;
    }
    public static void main(String args[])throws IOException{
        ConfigurationSource source = new ConfigurationSource(polygonWKTtoMultipolygonWKT.class.getClassLoader().getResource("log4j2.xml").openStream());
        Configurator.initialize(null, source);
        logger.debug("===========================> test");
        //logger.debug("===========================> test");
        List<Double> numbers = new ArrayList<Double>();
        String WKT ="POLYGON ((36631156.16340124 2053951.2098433475, 36631156.550284274 2053942.2098433475, 36631161.469711 2053942.2098433475, 36631160.93527403 2053951.2098433475, 36631188.45287607 2053951.2098433475, 36631188.45287607 2053951.2098433475, 36631188.45287607 2053943.2552433475, 36631188.45287607 2053943.2552433475, 36631188.28780783 2053942.2098433475, 36631182.72214949 2053942.2098433475, 36631182.52287607 2053949.1852433474, 36631182.3087349 2053951.2098433475, 36631164.27677607 2053951.2098433475, 36631164.27677607 2053950.0975433474, 36631162.52396096 2053942.2098433475, 36631153.29524993 2053942.2098433475, 36631153.11527045 2053951.2098433475, 36631136.83071462 2053951.2098433475, 36631135.99344532 2053942.2098433475, 36631133.97196079 2053942.2098433475, 36631129.73807607 2053947.7668433476, 36631129.49883301 2053951.2098433475, 36631126.41847607 2053951.2098433475, 36631156.16340124 2053951.2098433475))";
        try{
        String mutipolygonWKT = polygonToMultipolygon(WKT);}catch (Throwable e) {
            e.printStackTrace();
            logger.error(e.getMessage(),e);
        }
    }

}
*/